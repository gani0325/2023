"""
💛 싸움땅
인기 게임인 싸움땅은 다음과 같은 방식으로 진행됩니다.
게임은 n * n 크기의 격자에서 진행되며, 각각의 격자에는 무기들이 있을 수 있습니다. 
초기에는 무기들이 없는 빈 격자에 플레이어들이 위치하며 각 플레이어는 초기 능력치를 가집니다. 
각 플레이어의 초기 능력치는 모두 다릅니다. 게임은 다음과 같은 방식으로 진행됩니다.

아래 그림에서 빨간색 배경의 숫자는 총의 경우 공격력을, 플레이어의 경우 초기 능력치를 의미하며, 
노란색 배경의 숫자는 플레이어의 번호를 의미합니다.

하나의 라운드는 다음의 과정에 걸쳐 진행됩니다.
1-1. 첫 번째 플레이어부터 순차적으로 본인이 향하고 있는 방향대로 한 칸만큼 이동합니다. 
만약 해당 방향으로 나갈 때 격자를 벗어나는 경우에는 정반대 방향으로 방향을 바꾸어서 1만큼 이동합니다.
2-1. 만약 이동한 방향에 플레이어가 없다면 해당 칸에 총이 있는지 확인합니다. 총이 있는 경우, 해당 플레이어는 총을 획득합니다. 
플레이어가 이미 총을 가지고 있는 경우에는 놓여있는 총들과 플레이어가 가지고 있는 총 가운데 공격력이 더 쎈 총을 획득하고, 
나머지 총들은 해당 격자에 둡니다.
2-2-1. 만약 이동한 방향에 플레이어가 있는 경우에는 두 플레이어가 싸우게 됩니다. 
해당 플레이어의 초기 능력치와 가지고 있는 총의 공격력의 합을 비교하여 더 큰 플레이어가 이기게 됩니다. 
만일 이 수치가 같은 경우에는 플레이어의 초기 능력치가 높은 플레이어가 승리하게 됩니다. 
이긴 플레이어는 각 플레이어의 초기 능력치와 가지고 있는 총의 공격력의 합의 차이만큼을 포인트로 획득하게 됩니다.
2-2-2. 진 플레이어는 본인이 가지고 있는 총을 해당 격자에 내려놓고, 해당 플레이어가 원래 가지고 있던 방향대로 한 칸 이동합니다. 
만약 이동하려는 칸에 다른 플레이어가 있거나 격자 범위 밖인 경우에는 오른쪽으로 90도씩 회전하여 빈 칸이 보이는 순간 이동합니다. 
만약 해당 칸에 총이 있다면, 해당 플레이어는 가장 공격력이 높은 총을 획득하고 나머지 총들은 해당 격자에 내려 놓습니다.
2-2-3. 이긴 플레이어는 승리한 칸에 떨어져 있는 총들과 원래 들고 있던 총 중 가장 공격력이 높은 총을 획득하고, 
나머지 총들은 해당 격자에 내려 놓습니다.
위 과정을 1번부터 n번 플레이어까지 순차적으로 한 번씩 진행하면 1 라운드가 끝나게 되고, 그 결과는 다음과 같습니다

1번 라운드에 걸쳐 전체 플레이어가 획득한 포인트는 1번 사람부터 n번 사람까지 순서대로 [1, 0, 0, 0]입니다.
위의 과정을 한번더 반복하여 나온 2번 라운드 결과는 다음과 같으며, 
2번 라운드 이후 획득한 포인트 역시 1번 라운드와 동일하게 [1, 0, 0, 0]이 됩니다.

k 라운드 동안 게임을 진행하면서 각 플레이어들이 획득한 포인트를 출력하는 프로그램을 작성해보세요.

🧡 입력 형식
첫 번째 줄에 n, m, k가 공백을 사이에 두고 주어집니다. n은 격자의 크기, m은 플레이어의 수, k는 라운드의 수를 의미합니다.

이후 n개의 줄에 걸쳐 격자에 있는 총의 정보가 주어집니다. 각 줄에는 각각의 행에 해당하는 n개의 수가 공백을 사이에 두고 주어집니다. 
숫자 0은 빈 칸, 0보다 큰 값은 총의 공격력을 의미합니다.

이후 m개의 줄에 걸쳐 플레이어들의 정보 x, y, d, s가 공백을 사이에 두고 주어집니다. 
(x, y)는 플레이어의 위치, d는 방향, s는 플레이어의 초기 능력치를 의미하고 각 플레이어의 초기 능력치는 모두 다릅니다.
방향 d는 0부터 3까지 순서대로 ↑, →, ↓, ←을 의미합니다.

각 플레이어의 위치는 겹쳐져 주어지지 않으며, 플레이어의 초기 위치에는 총이 존재하지 않습니다.
    2 ≤ n ≤ 20
    1 ≤ m ≤ min(n 2 ,30)
    1 ≤ k ≤ 500
    1 ≤ 총의 공격력 ≤ 100,000
    1 ≤ s ≤ 100
    1 ≤ x, y ≤ n

💚 출력 형식
k 라운드 동안 게임을 진행하면서 각 플레이어들이 획득한 포인트를 공백을 사이에 두고 출력하세요.

🐧 입출력 예제
예제1
➡️ 입력:
5 4 1
1 2 0 1 2
1 0 3 3 1
1 3 0 2 3
2 1 2 4 5
0 1 3 2 0
1 3 2 3
2 2 1 5
3 3 2 2
5 1 3 4

➡️ 출력:
1 0 0 0
"""
EMPTY = (-1, -1, -1, -1, -1, -1)

# 변수 선언 및 입력:
n, m, k = tuple(map(int, input().split()))

# 각 칸마다 놓여있는 총 목록을 관리합니다.
gun = [
    [[] for _ in range(n)]
    for _ in range(n)
]
for i in range(n):
    nums = list(map(int, input().split()))
    for j in range(n):
        # 총이 놓여 있는 칸입니다.
        if nums[j] != 0:
            gun[i][j].append(nums[j])

# 각 칸마다 플레이어 정보를 관리합니다.
# 순서대로 (num, x, y, d, s, a) 정보를 관리합니다.
# (x, y)위치에서 방향 d를 보고 있으며
# 초기 능력치가 s인 num번 플레이어가
# 공격력이 a인 총을 들고 있음을 뜻합니다.
# 총이 없으면 a는 0입니다.
players = []
for i in range(m):
    x, y, d, s = tuple(map(int, input().split()))
    players.append((i, x - 1, y - 1, d, s, 0))

# 입력으로 주어지는
# 방향 순서대로
# dx, dy를 정의합니다.
# ↑, →, ↓, ←
dxs = [-1, 0, 1,  0]
dys = [0, 1, 0, -1]

# 플레이어들의 포인트 정보를 기록합니다.
points = [0] * m


# (x, y)가 격자를 벗어나는지 확인합니다.
def in_range(x, y):
    return 0 <= x and x < n and 0 <= y and y < n


# 현재 (x, y)위치에서 방향 d를 보고 있을 때
# 그 다음 위치와 방향을 찾아줍니다.
def get_next(x, y, d):
    nx, ny = x + dxs[d], y + dys[d]
    # 격자를 벗어나면
    # 방향을 뒤집어
    # 반대 방향으로 한 칸 이동합니다.
    if not in_range(nx, ny):
        # 반대 방향 : 0 <. 2 / 1 <. 3
        d = (d + 2) if d < 2 else (d - 2)
        nx, ny = x + dxs[d], y + dys[d]

    return (nx, ny, d)


# 해당 칸에 있는 Player를 찾아줍니다.
# 없다면 EMPTY를 반환합니다.
def find_player(pos):
    for i in range(m):
        _, x, y, _, _, _ = players[i]
        if pos == (x, y):
            return players[i]

    return EMPTY


# Player p의 정보를 갱신해줍니다.
def update(p):
    num, _, _, _, _, _ = p

    # Player의 위치를 찾아
    # 값을 갱신해줍니다.
    for i in range(m):
        num_i, _, _, _, _, _ = players[i]

        if num_i == num:
            players[i] = p
            break


# 플레이어 p를 pos 위치로 이동시켜줍니다.
def move(p, pos):
    num, x, y, d, s, a = p
    nx, ny = pos

    # 가장 좋은 총으로 갱신해줍니다.
    gun[nx][ny].append(a)
    gun[nx][ny].sort(reverse=True)
    a = gun[nx][ny][0]
    gun[nx][ny].pop(0)

    p = (num, nx, ny, d, s, a)
    update(p)


# 진 사람의 움직임을 진행합니다.
# 결투에서 패배한 위치는 pos입니다.
def loser_move(p):
    num, x, y, d, s, a = p

    # 먼저 현재 위치에 총을 내려놓게 됩니다.
    gun[x][y].append(a)

    # 빈 공간을 찾아 이동하게 됩니다.
    # 현재 방향에서 시작하여
    # 90'씩 시계방향으로
    # 회전하다가
    # 비어있는 최초의 곳으로 이동합니다.
    for i in range(4):
        ndir = (d + i) % 4
        nx, ny = x + dxs[ndir], y + dys[ndir]
        if in_range(nx, ny) and find_player((nx, ny)) == EMPTY:
            p = (num, x, y, ndir, s, 0)
            move(p, (nx, ny))
            break


# p2과 p2가 pos에서 만나 결투를 진행합니다.
def duel(p1, p2, pos):
    num1, _, _, d1, s1, a1 = p1
    num2, _, _, d2, s2, a2 = p2

    # (초기 능력치 + 총의 공격력, 초기 능력치) 순으로 우선순위를 매겨 비교합니다.

    # p1이 이긴 경우
    if (s1 + a1, s1) > (s2 + a2, s2):
        # p1은 포인트를 얻게 됩니다.
        points[num1] += (s1 + a1) - (s2 + a2)
        # p2는 진 사람의 움직임을 진행합니다.
        loser_move(p2)
        # 이후 p1은 이긴 사람의 움직임을 진행합니다.
        move(p1, pos)
    # p2가 이긴 경우
    else:
        # p2는 포인트를 얻게 됩니다.
        points[num2] += (s2 + a2) - (s1 + a1)
        # p1은 진 사람의 움직임을 진행합니다.
        loser_move(p1)
        # 이후 p2는 이긴 사람의 움직임을 진행합니다.
        move(p2, pos)


# 1라운드를 진행합니다.
def simulate():
    # 첫 번째 플레이어부터 순서대로 진행합니다.
    for i in range(m):
        num, x, y, d, s, a = players[i]

        # Step 1-1. 현재 플레이어가 움직일 그 다음 위치와 방향을 구합니다.
        nx, ny, ndir = get_next(x, y, d)

        # 해당 위치에 있는 전 플레이어 정보를 얻어옵니다.
        next_player = find_player((nx, ny))

        # 현재 플레이어의 위치와 방향을 보정해줍니다.
        curr_player = (num, nx, ny, ndir, s, a)
        update(curr_player)

        # Step 2. 해당 위치로 이동해봅니다.
        # Step 2-1. 해당 위치에 플레이어가 없다면 그대로 움직입니다.
        if next_player == EMPTY:
            move(curr_player, (nx, ny))
        # Step 2-2. 해당 위치에 플레이어가 있다면 결투를 진행합니다.
        else:
            duel(curr_player, next_player, (nx, ny))


# k번에 걸쳐 시뮬레이션을 진행합니다.
for _ in range(k):
    simulate()

# 각 플레이어가 획득한 포인트를 출력합니다.
for point in points:
    print(point, end=" ")
