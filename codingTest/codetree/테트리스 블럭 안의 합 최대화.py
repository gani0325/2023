# codetree 참고함
# 테트리스 블럭 안의 합 최대화 하기
# n×m 크기의 이차원 영역의 각 위치에 자연수 하나가 적힘
# 다섯가지 종류의 테트리스 블럭 중 한 개를 올려놓아 블럭이 놓인 칸 안에 적힌 숫자의 합이 최대가 될 때의 결과를 출력
# 테트리스 블럭은 자유롭게 회전하거나 뒤집을 수 있음

# 첫번째 줄에는 n과 m
# 두번째 줄부터 (n+1)번째 줄까지는 각 행의 숫자

# 테트리스 블록을 회전하거나 뒤집었을 때 가능한 모양은 총 19개
# 배열로 모든 모양 적고, 격자 순회하며 최대 합 구하기

# 변수 선언 및 입력
n, m = tuple(map(int, input().split()))
grid = [list(map(int, input().split())) for _ in range(n)]

# 가능한 모든 모양
blocks = [
    [  [1, 1, 1, 1],
       [0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 0, 0, 0],
       [1, 0, 0, 0],
       [1, 0, 0, 0],
       [1, 0, 0, 0] ],

     [ [1, 1, 0, 0],
       [1, 1, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 0, 0, 0],
       [1, 0, 0, 0],
       [1, 1, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 1, 0, 0],
       [0, 1, 0, 0],
       [1, 1, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 1, 0],
       [1, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 1, 0],
       [0, 0, 1, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 0, 0],
       [0, 1, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 0, 0],
       [1, 0, 0, 0],
       [1, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 0, 1, 0],
       [1, 1, 1, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 0, 0, 0],
       [1, 1, 1, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 0, 0, 0],
       [1, 1, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 1, 1, 0],
       [1, 1, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 0, 0],
       [0, 1, 1, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 1, 0, 0],
       [1, 1, 0, 0],
       [1, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 0, 0, 0],
       [1, 1, 0, 0],
       [1, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [1, 1, 1, 0],
       [0, 1, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 1, 0, 0],
       [1, 1, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 0, 0] ],

     [ [0, 1, 0, 0],
       [1, 1, 1, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0] ]   
]

# 주어진 위치가 격자를 벗어나는지 여부를 반환
def in_range(x, y):
    return 0 <= x and x < n and 0 <= y and y < m

# 주어진 위치에 대하여 가능한 모든 모양을 탐색하며 최대 합을 반환
def get_max_sum(x, y):
    max_sum = 0

    for shape in blocks:
        sum_of_nums = sum([
            grid[x + dx][y + dy]
            for dx in range(4)
            for dy in range(4)
            if in_range(x + dx, y + dy) and shape[dx][dy]
        ])
        max_sum = max(max_sum, sum_of_nums)
    
    return max_sum

# 격자의 각 위치에 대하여 탐색
max_sum = max([
    get_max_sum(i, j)
    for i in range(n)
    for j in range(m)
])

print(max_sum)

##################예제######################
"""
입력:
4 5
6 5 4 3 1
3 4 4 14 1
6 1 3 15 5
3 5 1 16 20

출력:
65
"""